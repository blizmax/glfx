%name-prefix "glfx"
%output "src/generated/glfxLALRParser.cpp"
%defines "src/generated/glfxLALRParser.hpp"
%{
	//#define YYFPRINTF glfxprintf
	#define YYDEBUG 1
    #include <iostream>
    #include <map>
    #include <string>
    #include <vector>
    #include <sstream>
    #include <algorithm>
    
    #include "glfxParser.h"
    #include "glfxClasses.h"
    #include "StringFunctions.h"

    using namespace std;
    using namespace glfxParser;
    
    #ifdef _MSC_VER
		// MS's C++ compiler is more strict than gcc
    
		// bison related
		// Disable the warning about default being present but no other cases in switch
		#pragma warning( disable:4065 )

		// No unistd.h (for flex)
		#define YY_NO_UNISTD_H
		#define YYERROR_VERBOSE
    #endif
    #include "glfxScanner.h"
    #include "glfxEffect.h"

    static void errSyn(const char *e);
    static void errSem(const string& str, int line=-1);

	RasterizerState buildRasterizerState;
	Struct buildStruct;
	PassState buildPassState;
	BlendState buildBlendState;
	DepthStencilState buildDepthStencilState;
	SamplerState buildSamplerState;
	TechniqueGroup buildTechniqueGroup;
	static int last_linenumber=0;
	static int current_filenumber=0;
	static int global_linenumber=0;
	ComputeLayout currentCsLayout;
	int maxVertexCount			=0;
	int last_recorded_linenum	=0;
	int global_linenum			=0;
	int filenum					=0;
	#pragma optimize("",off)
	bool is_equal(const string& A, const char * b)
	{
		string a = A;
		while (a.length()>0 && a[0] == '\n' || a[0] == ' ' || a[0] == '\t')
			a = a.substr(1, a.length() - 1);
		while (a.length()>0&&a[a.length() - 1] == '\n' || a[a.length() - 1] == ' ' || a[a.length() - 1] == '\t')
			a = a.substr(0, a.length() - 1);
		size_t sz = a.size();
		if (strlen(b) != sz)
			return false;
		for (size_t i = 0; i < sz; ++i)
			if (tolower(a[i]) != tolower(b[i]))
				return false;
		return true;
	}
	bool toBool(const string &str)
	{
		if(is_equal(str,"TRUE"))
			return true;
		else if(is_equal(str,"FALSE"))
			return false;
		else errSem("Expected boolean.");
		return false;
	}
	float toFloat(const string &str)
	{
		return (float)atof(str.c_str());
	}
	void WriteLineNumber(std::ostringstream &str,int fileno,int lineno)
	{
		str<<"#line "<< lineno << " " << fileno<<endl;
	}
	void WriteLineNumber(std::ostringstream &str,int lineno)
	{
		WriteLineNumber(str,current_filenumber,lineno);//.c_str()<<"\""<<endl;
	}
	int CurrentFilenumber()
	{
		return current_filenumber;
	}
	int LineNumberFromYYLine(int yylineno)
	{
		return yylineno+last_linenumber-global_linenumber;
	}
	bool write_line_number_next=false;
	void gSkip()
	{
		write_line_number_next=true;
	}
	void stringReplaceAll(std::string& str, const std::string& from, const std::string& to)
	{
		if(from.empty())
			return;
		size_t start_pos = 0;
		while((start_pos = str.find(from, start_pos)) != std::string::npos)
		{
			str.replace(start_pos, from.length(), to);
			start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
		}
	}
	static string GetLayoutForTemplateType(string s,string textureName)
	{
		// In HLSL, vec4 and float textures are "adaptable" and the actual texture might be a different format.
		//if(s==string("vec4")||s==string("float"))
		{
			// We want to be able to write both, so we will add in a #define rgba16_or_32f rgba32f or rgba16f
			// at the appropriate time.
			return string("layout(format_for_")+textureName+")";
		}
		return "";
	}
	static string GetEquivalentGLTextureType(string texture_type,string template_type)
	{
		stringReplaceAll(texture_type,"RWTexture","image");
		stringReplaceAll(texture_type,"Texture","sampler");
		if(template_type.find("uint")<template_type.length())
		{
			texture_type=string("u")+texture_type;
		}
		else if(template_type.find("int")<template_type.length())
		{
			texture_type=string("i")+texture_type;
		}
		return texture_type;
	}
	int GetIndexOfParameter(const vector<glfxstype::variable> &parameters,const string &name)
	{
		for(int i=0;i<parameters.size();i++)
		{
			if(name==parameters[i].identifier)
				return i;
		}
		return -1;
	}
	string getGLInputSemantic(int s);
	map<std::string,CompilableShader*> compilableShaders;
	
	Function buildFunction;
	TextureSampler *AddTextureSampler(string textureName,string samplerStateName)
	{
		auto i=buildFunction.textureSamplers.find((textureName+"_")+samplerStateName);
		if(i!=buildFunction.textureSamplers.end())
		{
			return i->second;
		}
		TextureSampler *ts=new TextureSampler;
		ts->textureName			=textureName;
		ts->samplerStateName	=samplerStateName;
		ts->global				=false;
		buildFunction.textureSamplers[ts->textureSamplerName()]=(ts);
		buildFunction.textureSamplersByTexture[textureName].insert(ts);
		buildFunction.textureSamplersBySampler[ts->samplerStateName].insert(ts);
		return ts;
	}
	string ComputeLayout::text() const
	{
		string tt=stringFormat("layout(local_size_x=%d,local_size_y=%d,local_size_z=%d) in;",x,y,z);
		return tt;
	}
	string ShaderTypeToString(ShaderType s)
	{
		switch(s)
		{
		case VERTEX_SHADER:
		return "Vertex";
		case TESSELATION_CONTROL_SHADER:		//= Hull shader
		return "Hull (TC)";
		case TESSELATION_EVALUATION_SHADER:	//= Domain Shader
		return "Domain (TE)";
		case GEOMETRY_SHADER:
		return "Geometry";
		case FRAGMENT_SHADER:
		return "Pixel (Fragment)";
		case COMPUTE_SHADER:
		return "Compute";
		default:
		return "Unknown";
		}
	};
	GLTextureType GetTextureType(const Function &function,const string &textureName)
	{
		for(vector<glfxstype::variable>::const_iterator i=function.parameters.begin();i!=function.parameters.end();i++)
		{
			if(textureName==i->identifier)
				return (GLTextureType)i->type_enum;
		}
		auto j = gEffect->GetDeclaredTextures().find(textureName);
		if (j != gEffect->GetDeclaredTextures().end())
			return (GLTextureType)j->second->type_enum;
		return unknwownTextureType;
	}
	GLTextureType ToGLTextureType(int t);
	bool IsRWTexture(GLTextureType glTextureType)
	{
		switch(glTextureType)
		{
			case gimage1D:
			case gimage2D:
			case gimage3D:
			case gimageCube:
			case gimage2DRect:
			case gimage1DArray:
			case gimage2DArray:
			case gimageCubeArray:
			case gimageBuffer:
			case gimage2DMS:
			case gimage2DMSArray:
				return true;
				break;
			default:
				return false;
		break;
		}
	}
	string GetSizeFunction(string textureName,string x,string y,string z)
	{
		GLTextureType glTextureType	=GetTextureType(buildFunction,textureName);
		bool lod_param=false;
		switch(glTextureType)
		{
			case gsampler1D:
			case gsampler2D:
			case gsampler3D:
			case gsamplerCube:
			case sampler1DShadow:
			case sampler2DShadow:
			case samplerCubeShadow:
			case gsamplerCubeArray:
			case gsampler1DArray:
			case gsampler2DArray:
			case sampler1DArrayShadow:
			case sampler2DArrayShadow:
				lod_param=true;
			default:
				break;
		}
		int return_size=GetTextureDimension(glTextureType);
		ostringstream full_expr;
		// NOTE the spaces around the textureName. We might need to replace it with a sampler name, so we make sure we can find it
		// as a whole word easily.
		full_expr<<"{ivec"<<return_size<<" iv=";
		if(IsRWTexture(glTextureType))
		{
			full_expr<<"imageSize";
		}
		else
			full_expr<<"textureSize";
		full_expr<<"( "<<textureName<<" ";
		if(lod_param)
			full_expr<<",0";
		full_expr<<"); "<<x<<"=iv.x;";
		if(return_size>1&&y.size()>0)
			full_expr<<y<<"=iv.y;";
		if(return_size>2&&z.size()>0)
			full_expr<<z<<"=iv.z;";
		full_expr<<"}\n";
		return full_expr.str();
	}
	bool IsDeclared(string name)
	{
		if(gEffect->IsDeclared(name))
			return true;
		for(auto i=buildFunction.parameters.begin();i!=buildFunction.parameters.end();i++)
		{
			if(i->identifier==name)
				return true;
		}
		return false;
	}
	string GetDeclaredType(string name)
	{
		if(gEffect->IsDeclared(name))
			return gEffect->GetDeclaredType(name);
		for(auto i=buildFunction.parameters.begin();i!=buildFunction.parameters.end();i++)
		{
			if(i->identifier==name)
				return i->type;
		}
		return "unknown";
	}
	bool IsBufferType(int t);
%}

%token WHITESPACE UNIFORM REGISTER SHADER CONSTANT_BUFFER PROGRAM INTERFACE IDENTIFIER SAMPLE SAMPLE_LOD LOAD GET_DIMS STORAGEQ GL_FRAGDEPTH SHADER_COMMAND SET_RASTERIZER_COMMAND SET_DEPTH_COMMAND SET_BLEND_COMMAND
%token SV_DISPATCHTHREADID SV_GROUPTHREADID SV_GROUPID SV_VERTEXID NUM INCLUDE SAMPLER P_FLOAT
%token LAYOUT LINE TECHNIQUE PASS GROUP RENDER_STATE_DECL QUOTED_STRING SHADER_LINE SHADER_TYPE COMPILE_SHADER CONSTRUCT_GS_WITH_SO STRUCT
%token PRAGMA DEFINE UNDEF MACRO_DEFINITION EOL DECL_SHADER PROFILE  
%token WARNING DEF MESSAGE PACK_MATRIX
%token RW_TEXTURE2D RW_TEXTURE3D RW_TEXTURE2DARRAY RW_TEXTURE3D_FLOAT4 TEXTURE2DMS TEXTURE2D TEXTURE2DARRAY TEXTURE3D TEXTURECUBE IMAGE3D KNOWN_TYPE STRUCTUREDBUFFER RW_STRUCTUREDBUFFER
%token RETURN BREAK CONTINUE DO FOR GOTO IF WHILE ELSE 
%token TIMES_EQUALS OVER_EQUALS PERCENT_EQUALS PLUS_EQUALS MINUS_EQUALS LEFT_SHIFT_EQUALS RIGHT_SHIFT_EQUALS AND_EQUALS XOR_EQUALS OR_EQUALS
%token AND OR LESS_EQ GRTR_EQ LEFT_SHIFT RIGHT_SHIFT PLUS_PLUS MINUS_MINUS EQ_EQ NOT_EQ
%token SA_MAXVERTEXCOUNT SA_NUMTHREADS
%token SATURATE
%token SHADER_PROFILE 
%token COMMENT
//filter_mode
%token MIN_MAG_MIP_POINT MIN_MAG_POINT_MIP_LINEAR MIN_POINT_MAG_LINEAR_MIP_POINT MIN_POINT_MAG_MIP_LINEAR MIN_LINEAR_MAG_MIP_POINT MIN_LINEAR_MAG_POINT_MIP_LINEAR MIN_MAG_LINEAR_MIP_POINT MIN_MAG_MIP_LINEAR ANISOTROPIC
%token SRC_ALPHA INV_SRC_ALPHA ZERO ONE SRC_COLOR INV_SRC_COLOR DEST_ALPHA INV_DEST_ALPHA DEST_COLOR INV_DEST_COLOR SRC_ALPHA_SAT BLEND_FACTOR INV_BLEND_FACTOR SRC1_COLOR INV_SRC1_COLOR SRC1_ALPHA INV_SRC1_ALPHA
%token BLEND_OP_ADD BLEND_OP_SUBTRACT BLEND_OP_MAX
%token CULL_FRONT_FACES CULL_BACK_FACES
%token RENDERSTATE_RVALUE_NONE
%token FILL_MODE_SOLID FILL_MODE_WIREFRAME
%token DEPTH_PASS_ALWAYS DEPTH_PASS_NEVER DEPTH_PASS_LESS DEPTH_PASS_GREATER DEPTH_PASS_LESS_EQUAL DEPTH_PASS_GREATER_EQUAL
%token TEXTURE_WRAP TEXTURE_MIRROR TEXTURE_CLAMP
%%

prog : prog tok
    | { // Initialization code
	    sharedCode.str("");    // clear the stream
		sharedCode<<"#define GLSL\n";
// Some GLSL compilers can't abide seeing a "discard" in the source of a shader that isn't a fragment shader, even if it's in unused, shared code.
	sharedCode<<"#if !defined(GLFX_FRAGMENT_SHADER)\n"
							"#define discard\n"
						"#endif\n";
		sharedCode<<"float saturate(float x)"
						"{"
						"	return clamp(x,0.0,1.0);"
						"}"
						"\n"
						"vec2 saturate(vec2 x)"
						"{"
						"	return clamp(x,vec2(0.0,0.0),vec2(1.0,1.0));"
						"}"
						"\n"
						"vec3 saturate(vec3 x)"
						"{"
						"	return clamp(x,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));"
						"}"
						"\n"
						"vec4 saturate(vec4 x)"
						"{"
						"	return clamp(x,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));"
						"}\n";
		

	sharedCode<<"vec4 mul(mat4 m,vec4 v)"
							"{"
							"	return m*v;"
							"}\n"
							"vec3 mul(mat3 m,vec3 v)"
							"{"
							"	return m*v;"
							"}\n"
							"vec2 mul(mat2 m,vec2 v)"
							"{"
							"	return m*v;"
							"}\n"
							"vec4 mul(vec4 v,mat4 m)"
							"{"
							"	return v*m;"
							"}\n"
							"vec3 mul(vec3 v,mat3 m)"
							"{"
							"	return v*m;"
							"}\n"
							"vec2 mul(vec2 v,mat2 m)"
							"{"
							"	return v*m;"
							"}\n";
	    gLexPassthrough=true;
	};
	tok :  EOL
	{
	}
	| line_statement
	{
	}
	| PRAGMA WARNING '(' warning-specifier ':' NUM ')'
	{
	}
	| optional_uniform texture_type optional_templateval IDENTIFIER optional_register_semantic ';'
	{
		string texture_type=$2.strs[0];
		GLTextureType type_enum = ToGLTextureType($2.token);
		bool compute_only		=(texture_type==string("image3D"))||(texture_type.substr(0,2)==string("RW"));
		
		stringReplaceAll(texture_type,"RWTexture","image");
		string template_type	=$3.strs[0];
		if(template_type.length()==0)
			template_type="vec4";
		string texture_name		=$4.strs[0];
		string layout;
		if(compute_only)
			layout=GetLayoutForTemplateType(template_type,texture_name)+" ";
		string type=GetEquivalentGLTextureType(texture_type,template_type);

		DeclaredTexture dec;
		dec.variant			=compute_only&&IsRWTexture(type_enum);//(template_type==string("vec4"));
		dec.file_number		=current_filenumber;
		dec.line_number		=$1.lineno+last_linenumber-global_linenumber;
		dec.type			=type;
		dec.texel_format	=template_type;
		dec.type_enum		=type_enum;
		dec.layout			=layout;
		gEffect->DeclareTexture(texture_name,dec);

		ostringstream decl;

	}

	| optional_uniform buffer_type optional_templateval IDENTIFIER ';'
	{
		//string buffer_type=$2.strs[0];
		bool compute_only=($2.token==RW_STRUCTUREDBUFFER);
		ostringstream decl;
		if(compute_only)
			sharedCode<<"#ifdef IN_COMPUTE_SHADER\n";
		string template_type=$3.strs[0];
		string buffer_name=$4.strs[0];
		decl<<"layout(std430) buffer "<<buffer_name<<"_\n{\n\t";
		decl<<template_type<<" "<<buffer_name<<"[];\n";
		decl<<"};\n";
		sharedCode<<decl.str();
		if(compute_only)
			sharedCode<<"#endif\n";
	}
	| optional_uniform IDENTIFIER IDENTIFIER ';'
	{
		ostringstream decl;
		decl<<$1.strs[0]<<" "<<$2.strs[0]<<" "<<$3.strs[0]<<";";
		sharedCode<<decl.str();
	}
	| '[' SA_MAXVERTEXCOUNT '(' NUM ')' ']'
	{
		maxVertexCount=$4.num;
	}
	| '[' SA_NUMTHREADS '(' NUM ',' NUM ',' NUM ')' ']'
	{
		currentCsLayout.x=$4.num;
		currentCsLayout.y=$6.num;
		currentCsLayout.z=$8.num;
	}
	| LAYOUT cs_layout_spec IDENTIFIER ';'
	{
	}
	| LAYOUT normal_layout_spec
	{
		string str=$1.strs[0]+" "+$2.strs[0];
		glfxWrite(str.c_str());
		glfxPopState();
	}
	| RW_TEXTURE3D_FLOAT4 IDENTIFIER ';'
	{
		string str="layout(rgba32f) uniform image3D ";
		str+=$2.strs[0]+";";
		glfxWrite(str.c_str());
	}
	| RW_TEXTURE3D_FLOAT4 IDENTIFIER ','
	{
		string str="layout(rgba32f) image3D ";
		str+=$2.strs[0]+",";
		glfxWrite(str.c_str());
	}
	| DEFINE MACRO_DEFINITION EOL
	{
		string name					=$2.strs[0];
	}
	| UNDEF IDENTIFIER EOL
	{
		string name		=$2.strs[0];
		string str		=string("#undef ")+name+"\n";
		glfxWrite(str.c_str()); 
	}
	| STRUCT IDENTIFIER struct_definition ';'
	{
		string name					=$2.strs[0];
		gEffect->DeclareStruct(name,buildStruct);
		sharedCode<<"struct "<<$2.strs[0]<<"\n{\n";
		for(int i=0;i<(int)buildStruct.m_structMembers.size();i++)
		{
			const StructMember &m=buildStruct.m_structMembers[i];
			sharedCode<<m.type<<" "<<m.name<<";\n";
		}
		WriteLineNumber(sharedCode,current_filenumber,$4.lineno+last_linenumber-global_linenumber);
		sharedCode<<"};";
		// Set to default:
		buildStruct					=Struct();
	}
	| RENDER_STATE_DECL IDENTIFIER optional_register_semantic optional_render_state_list ';'
	{
		$$.lineno		=$4.lineno;
		RenderState t=renderState;
		string name=$2.strs[0];
		if(t==RASTERIZER_STATE)
		{
			gEffect->DeclareRasterizerState(name,buildRasterizerState);
			// Set to default:
			buildRasterizerState=RasterizerState();
		}
		if(t==BLEND_STATE)
		{
			gEffect->DeclareBlendState(name,buildBlendState);
			// Set to default:
			buildBlendState=BlendState();
		}
		if(t==DEPTHSTENCIL_STATE)
		{
			gEffect->DeclareDepthStencilState(name,buildDepthStencilState);
			// Set to default:
			buildDepthStencilState=DepthStencilState();
		}
		if(t==SAMPLER_STATE)
		{
			gEffect->DeclareSamplerState(name,buildSamplerState);
			// Set to default:
			buildSamplerState=SamplerState();
		}
		int true_linenumber=$4.lineno+(last_linenumber-global_linenumber);
	
	}
	| PROFILE SHADER_PROFILE '(' NUM ')' ';'
	{
		string profileName		=$2.strs[0];
		int profileNum			=$4.num;
		if(!gEffect->SetVersionForProfile(profileNum,profileName))
			glfxWarning("redefining profile ");
	}
	| DECL_SHADER IDENTIFIER '=' shader_compile ';'
	{
		// We here declare that a named shader should be compiled with the specified profile (e.g. GLSL 4.30)
		// and assign a variable name to the shader/profile combination. Later on, in pass definitions,
		// we can assign the shader to one or more passes.
		string lvalCompiledShaderName		=$2.strs[0];
		string rvalCompiledShaderName		=$4.strs[0];
		gEffect->AddCompiledShader($2.sType,lvalCompiledShaderName,rvalCompiledShaderName);
	}
	| LAYOUT lex_fx layout_params lex_passthrough
	{
	}
	| CONSTANT_BUFFER IDENTIFIER optional_register_semantic shader_fx struct_definition ';' lex_passthrough
	{
		string bufferName	=$2.strs[0];
		string def			=$5.strs[0];
		string semantic		=$3.strs[0];
		int buffer_number	=$3.num;

		ostringstream str;
		WriteLineNumber(str,current_filenumber,$1.lineno+(last_linenumber-global_linenumber));
		str<< "layout(std140) uniform "<<$2.strs[0]<<$5.strs[0]<<";\n";
		WriteLineNumber(str,current_filenumber,glfxget_lineno()+(last_linenumber-global_linenumber));

		glfxWrite(str.str().c_str());
		// Set to default:
		buildStruct					=Struct();
	}
	// function definition
    | IDENTIFIER IDENTIFIER '(' param_declaration_list ')' function_fx function_content lex_passthrough
	{
		string functionName					=$2.strs[0];
		buildFunction.returnType			=$1.strs[0];
		buildFunction.content				=$7.strs[0];
	
		buildFunction.parameters			=*$4.vars;
		delete $4.vars;
		
			//WriteLineNumber(sharedCode,current_filenumber,glfxget_lineno()+(last_linenumber-global_linenumber));
		buildFunction.current_filenumber	=current_filenumber;
		buildFunction.main_linenumber		=$1.lineno;
		buildFunction.content_linenumber	=$1.lineno+(last_linenumber-global_linenumber);
	buildFunction.name=functionName;
//		buildFunction.source				=str.str();
		Function *f							=gEffect->DeclareFunction(functionName,buildFunction);
		buildFunction.clear();
	}
	// GL-style, e.g. shader VSMain(in type parameter,out type parameter) function_content
    | shader_and_layout IDENTIFIER IDENTIFIER '(' param_declaration_list ')' optional_return_semantic function_content lex_passthrough
	{
		CompilableShader &sh=*(compilableShaders[$3.strs[0]]=new CompilableShader);
		int line_number			=last_linenumber-global_linenumber;
		sh.shaderName			=$3.strs[0];
		sh.maxGSVertexCount		=maxVertexCount;

		buildFunction.returnType			=$2.strs[0];
		buildFunction.content				=$8.strs[0];
		buildFunction.parameters			=*$5.vars;
		buildFunction.current_filenumber	=current_filenumber;
		buildFunction.main_linenumber		=$1.lineno;
		buildFunction.content_linenumber	=$1.lineno+line_number;

		sh.returnable			=$8.strs[1];
		sh.main_linenumber		=buildFunction.content_linenumber;
		sh.content_linenumber	=$8.lineno+line_number;
		sh.current_filenumber	=current_filenumber;
		sh.csLayout				=currentCsLayout;
		
		buildFunction.name=sh.shaderName;

		Function *f				=gEffect->DeclareFunction(sh.shaderName,buildFunction);
		sh.function=f;
		buildFunction.textureSamplers.clear();	// so the pointers won't be freed later.

		for(std::map<std::string,TextureSampler*>::const_iterator i=sh.function->textureSamplers.begin();i!=sh.function->textureSamplers.end();i++)
		{
			if(!gEffect->DeclareTextureSampler(i->second))
				errSem(string("Can't find texture declaration for ")+i->first);
		}

		buildFunction.clear();
		delete $5.vars;
	//	sharedCode<<"#line "<<(glfxget_lineno()+(last_linenumber-global_linenumber))<<" "<<current_filenumber<<endl;
	}
    | PROGRAM lex_fx IDENTIFIER '{' prog_def '}' lex_passthrough
	{
		$5.prog->m_separable=$1.boolean;
	}
	| technique_decl
	{
	};
	| GROUP lex_fx IDENTIFIER '{' technique_decls '}' lex_passthrough
	{
		string groupName=$3.strs[0];
		gEffect->AddTechniqueGroup(groupName,buildTechniqueGroup);
		buildTechniqueGroup.m_techniques.clear();
	};
	line_statement: LINE lex_fx NUM NUM lex_passthrough EOL
	{
		last_linenumber		=$3.num;
		current_filenumber	=$4.num;
		global_linenumber	=$1.lineno+1;	// the line AFTER the #line directve.
		WriteLineNumber(sharedCode,current_filenumber,last_linenumber);
	}
	ignore_line_statement: LINE NUM NUM EOL
	{
		last_linenumber		=$2.num;
		current_filenumber	=$3.num;
		global_linenumber	=$1.lineno;
	  $$.strs[0]	="";
	}
	shader_and_layout: SHADER shader_fx
	{
		$$.strs[0]	=$1.strs[0];
		$$.lineno	=$1.lineno;
	}
	texture_type: TEXTURE2D|TEXTURE3D|TEXTURE2DMS|TEXTURE2DARRAY|IMAGE3D|RW_TEXTURE2D|RW_TEXTURE3D|RW_TEXTURE2DARRAY|TEXTURECUBE
	{
		$$.strs[0]	=$1.strs[0];
		$$.num		=$1.num;
		$$.token	=$1.token;
	};
	buffer_type: STRUCTUREDBUFFER|RW_STRUCTUREDBUFFER
	{
		$$.strs[0]	=$1.strs[0];
		$$.num		=$1.num;
		$$.token	=$1.token;
	};
	optional_templateval: '<' IDENTIFIER '>'
	{
		$$.strs[0]	=$2.strs[0];
		$$.num		=1;
	}
	|
	{
		$$.strs[0]	="";
		$$.num		=0;
	}
layout_params:'(' NUM ',' NUM ',' NUM ')'
{
	std::string ret="(";
	ret+=$2.strs[0];
	ret+=",";
	ret+=$4.strs[0];
	ret+=",";
	ret+=$6.strs[0];
	ret+=")";
	$$.strs[0]=ret;
	currentCsLayout.x=$2.num;
	currentCsLayout.y=$4.num;
	currentCsLayout.z=$6.num;
};
warning-specifier: IDENTIFIER
			  {
			  }
			  | NUM
			  {
			  }
technique_decls: technique_decls group_technique_decl
			  {
			  }
			  |
			  group_technique_decl
			  {
			  }
group_technique_decl: TECHNIQUE IDENTIFIER '{' tech_def '}'
	{
		buildTechniqueGroup.m_techniques[$2.strs[0]] = $4.tech;
	};
technique_decl: TECHNIQUE lex_fx IDENTIFIER '{' tech_def '}' lex_passthrough
	{
		string techname=$3.strs[0];
		gEffect->AddTechnique(techname,"",$5.tech);
	};
cs_layout_spec: '(' cs_layout ')'
		  {
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		  };
normal_layout_spec: '(' tx_layout ')'
		 {
				$$.layoutType=NORMAL_LAYOUT_TYPE;
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		 };
tx_layout: tx_layout ',' layout_s
				{
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
					| layout_s
				{
				$$.strs[0]=$1.strs[0];
				};
layout_s: layout_el
			{
				$$.strs[0]=$1.strs[0];
			}
			| IDENTIFIER
			{
				$$.strs[0]=$1.strs[0];
			};
cs_layout: layout_el ',' layout_el ',' layout_el
		  {
				currentCsLayout.x=$1.num;
				currentCsLayout.y=$3.num;
				currentCsLayout.z=$5.num;
				$$.layoutType=CS_LAYOUT_TYPE;
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
		  };
layout_el: IDENTIFIER '=' layout_def
		   {
				$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				$$.num=$3.num;
		   };

layout_def: IDENTIFIER
		   {
				$$.strs[0]=$1.strs[0];
		   }
		   | NUM
		   {
				$$.strs[0]=$1.strs[0];
		   }
lex_fx :
{ /* Switch lex to fx scanning */
	read_shader=false;
	read_function=false;
    gLexPassthrough=false;
};

shader_fx:
{
	read_shader=true;
	read_function=false;
    gLexPassthrough=false;
};

function_fx:
{
	read_function=true;
	read_shader=false;
    gLexPassthrough=false;
}

lex_passthrough :
{ /* Switch lex to passthrough mode */
    gLexPassthrough=true;
};

function_content : '{' statement_list '}' { /* Read next block */
    $$.strs[0]=$2.strs[0];
	// string 1 is the return value, if present.
	$$.strs[1]= $2.strs[1];
    $$.lineno= $2.lineno;
};

optional_return_semantic: ':' IDENTIFIER
 {
    $$.strs[0]=$1.strs[0]+$2.strs[0];
 }
 |
 {
    $$.strs[0]="";
 }
struct_definition: '{' struct_member_list '}'
{
    $$.strs[0]="{\n";
	$$.strs[0]+=($2.strs[0]+"\n}\n");
}
struct_member_list: struct_member_list struct_element
{
	string list			=$1.strs[0];
	string new_member	=$2.strs[0];
    $$.strs[0]=(list+"\n")+new_member;
}
| struct_element
{
	string member	=$1.strs[0];
    $$.strs[0]=member;
}
struct_element: struct_memb
{
	string str=$1.strs[0];
	//if(write_line_number_next)
//		str=
    $$.strs[0]	=str;
}
|
ignore_line_statement
{
	$$.lineno = $1.lineno;
	$$.num = -1;
    $$.strs[0]	="";
}
| COMMENT
{
	gSkip();
}
| WHITESPACE
{
	gSkip();
}
struct_memb : optional_uniform IDENTIFIER IDENTIFIER opt_sq optional_semantic ';'
{
	$$.lineno		=$4.lineno;
	string unif		=$1.strs[0];
	string type		=$2.strs[0];
	string name		=$3.strs[0];
	string sq		=$4.strs[0];
	string sem		=$5.strs[0];
	StructMember s;
	s.type		=type;
	s.semantic	=sem;
	s.name		=name+sq;
	buildStruct.m_structMembers.push_back(s);
	$$.strs[0]=(unif.length()?(unif+" "):"");
    $$.strs[0]+=(type+" ")+name;
	$$.strs[0]+=sq;
	$$.strs[0]+=sem.length()?(string(": ")+sem):"";
	$$.strs[0]+=";";
}
optional_uniform: UNIFORM
{
    $$.strs[0]="uniform";
}
|
{
    $$.strs[0]="";
}
param_declaration_list : param_declaration_list ',' param_declaration
	{
		$$.vars		=$1.vars;
		$$.strs[0]	=($1.strs[0]+",")+$3.strs[0];

		YYSTYPE::variable var;
		var.storage		=$3.strs[1];
		var.type		=$3.strs[2];
		var.identifier	=$3.strs[3];
		var.template_	=$3.strs[4];
		var.type_enum = ToGLTextureType($3.token);
		$$.vars->push_back(var);
		buildFunction.parameters.push_back(var);
	}
    | param_declaration
	{
		YYSTYPE::variable var;
		string s1	=$1.strs[0];
		$$.strs[0]	=s1;
		var.storage		=$1.strs[1];
		var.type		=$1.strs[2];
		var.identifier	=$1.strs[3];
		var.template_	=$1.strs[4];
		var.type_enum = ToGLTextureType($1.token);
    
		$$.vars = new vector<YYSTYPE::variable>;
		$$.vars->push_back(var);
		buildFunction.parameters.push_back(var);
	}
    |
	{
		$$.strs[0]	="";
		$$.vars = new vector<YYSTYPE::variable>;
	};

param_declaration: param opt_sq location
{
    ostringstream prepend;
	string template_		=$1.strs[0];
	string location			=$3.strs[1];
    switch($3.rType)
	{
    case REGISTER_INT:
        prepend<<"layout(location="<<$3.num<<") ";
        break;
    case REGISTER_NAME:
	// GL Doesn't recognize arbitrary text for this.
        //prepend<<"layout(location="<<$3.strs[0]<<") ";
        break;
    case SEMANTIC:
		template_=getGLInputSemantic($3.num);
        break;
    }
    prepend<<$1.strs[1];

	string storage	=prepend.str();
	string type		=$1.strs[2];
	string id		=$1.strs[3]+$2.strs[0];
	string all		=(($1.strs[1]+" ")+$1.strs[2]+" ")+id+$3.strs[0];
    $$.strs[0]	=all;
    $$.strs[1]	=storage;
    $$.strs[2]	=type;
    $$.strs[3]	=id;
	$$.token	=$1.token;
    $$.strs[4]	=template_;
};

opt_sq: '[' opt_num ']'
				{
					$$.strs[0]=(string("[")+$2.strs[0])+"]";
					$$.num=$2.num;
				}
				|
				{
					$$.strs[0]="";
					$$.num=0;
				};
opt_num: NUM
				{
					$$.strs[0]=$1.strs[0];
					$$.num=$1.num;
				}
				|
				{
					$$.strs[0]="";
					$$.num=0;
				}
// NOTE: Need comprehensive arithemetic for declaration integers/
				| NUM '*' NUM
				{
					$$.num=$1.num*$3.num;
					$$.strs[0]=stringFormat("%d",$$.num);
				}
param : opt_storage type_name optional_templateval IDENTIFIER
	{
		string storage	=$1.strs[0];
		string type		=$2.strs[0];
		string template_=$3.strs[0];
		// TODO: We discard template information in parameters. Should we insert a layout spec?
	
		
		string id		=$4.strs[0];
		if(template_.length()>=4&&(template_.substr(0,4)==string("uint")||template_.substr(0,4)==string("uvec")))
			type=string("u")+type;
		else if(template_.length()>=4&&template_.substr(0,4)==string("ivec"))
			type=string("i")+type;
		else if(template_.length()>=3&&template_.substr(0,3)==string("int"))
			type=string("i")+type;
		else if(IsBufferType($2.token))
		{
			if(template_.length()>0)
				type=template_+"[]";
		}
		$$.strs[0]		=template_;
		$$.strs[1]		=storage;
		$$.strs[2]		=type;
		$$.strs[3]		=id;
		$$.token		=$2.token;
	};
type_name: IDENTIFIER
			{
				$$.strs[0]		=$1.strs[0];
				$$.token		=$1.token;
			}
			| texture_type
			{
				$$.strs[0]		=$1.strs[0];
				$$.token		=$1.token;
			}
			| buffer_type
			{
				$$.strs[0]		=$1.strs[0];
				$$.token		=$1.token;
			}
opt_storage : STORAGEQ
	{
		$$.strs[0]=$1.strs[0];
	}
	|
	{
		$$.strs[0]="";
	}
input_semantic:	SV_DISPATCHTHREADID
	{
		$$.strs[0]=$1.strs[0];
		$$.num=SV_DISPATCHTHREADID;
	}
	| SV_GROUPID 
	{
		$$.strs[0]=$1.strs[0];
		$$.num=SV_GROUPID;
	}
	| SV_GROUPTHREADID
	{
		$$.strs[0]=$1.strs[0];
		$$.num=SV_GROUPTHREADID;
	}
	| SV_VERTEXID
	{
		$$.strs[0]=$1.strs[0];
		$$.num=SV_VERTEXID;
	}
location : ':' NUM
	{
		$$.num=$2.num;
		$$.rType=REGISTER_INT;
	}
    | ':' input_semantic
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=SEMANTIC;
		$$.num=$2.num;
	}
    | ':' IDENTIFIER
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=REGISTER_NAME;
	}
    |
	{
		$$.rType=REGISTER_NONE;
	}
;

tech_def : pass_list
{
	Technique *t = new Technique(*($1.passes));
	$$.tech = t;
	delete $1.passes;
};

pass_list: pass_list pass_def
{
	$$.passes				=($1.passes);
	map<string,Program> &passes=*$$.passes;
	string name			=$2.strs[0];
	Program *p			=$2.prog;
	if(p)
	{
		passes[name]	=*(p);
	}
	delete $2.prog;
}
| pass_def
{
	map<string,Program> *m=new map<string,Program>;
	$$.passes = m;
	string name = $1.strs[0];
	Program *p = $1.prog;
	if (p)
	{
		Program &newp = (*m)[name];
		newp= *p;
	}
	delete p;
};

pass_def: PASS IDENTIFIER '{' prog_def '}'
{
	$4.prog->m_separable	= $1.boolean;
	$$.prog					= $4.prog;
	$$.strs[0]				= $2.strs[0];
}

prog_def : shaders_list
{
	$$.prog = new Program(*($1.shaders), buildPassState, gEffect->GetTextureSamplersByShader(), $1.strs[2]);
    delete $1.shaders;
	buildPassState			=PassState();
};

shaders_list : shaders_list shader_def
	{
		map<ShaderType, Program::Shader>* map1=$1.shaders;
		ShaderType sType				=$2.sType;
		string preamble					=$2.strs[0];
		string name						=$2.strs[1];
		string compiledShaderName		=$2.strs[3];
		$$.strs[2]						=$1.strs[2]+$2.strs[2];// compute layout
		CompiledShaderMap::const_iterator i	=gEffect->GetCompiledShaders().find(compiledShaderName);
		if(i==gEffect->GetCompiledShaders().end())
			(*map1)[sType].compiledShader	=NULL;
		else
			(*map1)[sType].compiledShader	=i->second;
		(*map1)[sType].preamble			=preamble;
		(*map1)[sType].name				=name;
		$$.shaders						=map1;
	}
	| shader_def
	{
		map<ShaderType, Program::Shader>* map1=new map<ShaderType, Program::Shader>();
		string preamble				=$1.strs[0];
		string name					=$1.strs[1];
		string compiledShaderName	=$1.strs[3];
		ShaderType sType			=$1.sType;
		$$.strs[0]					=$1.strs[0];
		$$.strs[1]					=$1.strs[1];
		$$.strs[2]					=$1.strs[2];
		$$.strs[3]					=compiledShaderName;
		CompiledShaderMap::const_iterator i=gEffect->GetCompiledShaders().find(compiledShaderName);
		if(i==gEffect->GetCompiledShaders().end())
			(*map1)[sType].compiledShader	=NULL;
		else
			(*map1)[sType].compiledShader	=i->second;
		$$.sType							=sType;
		(*map1)[sType].name					=name;
		(*map1)[sType].preamble				=preamble;
		$$.shaders=map1;
	}
	| shaders_list shader_fn
	{
		//.map<ShaderType, Program::Shader>* map1=$1.shaders;
		$$.shaders=$1.shaders;
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.strs[2]	=$1.strs[2];
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	}
	| shader_fn
	{
		map<ShaderType, Program::Shader>* map1=new map<ShaderType, Program::Shader>();
		$$.shaders	=map1;
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.strs[2]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	};
vec4: IDENTIFIER '(' P_FLOAT ',' P_FLOAT ',' P_FLOAT ',' P_FLOAT ')'
	  {
		  $$.strs[0]=$1.strs[0]+"(";
		  $$.strs[0]+=$3.strs[0]+",";
		  $$.strs[0]+=$5.strs[0]+",";
		  $$.strs[0]+=$7.strs[0]+",";
		  $$.strs[0]+=$9.strs[0]+")";
	  };
	
shader_fn : SET_RASTERIZER_COMMAND '(' IDENTIFIER ')' ';'
			 {
				 string rast_name=$3.strs[0];
			 }
			 | SET_DEPTH_COMMAND '(' IDENTIFIER ',' NUM ')' ';'
			 {
				 string depth_name=$3.strs[0];
				 int index=$5.num;
				 buildPassState.depthStencilState=depth_name;
			 }
			 | SET_BLEND_COMMAND '(' IDENTIFIER ',' vec4 ',' NUM ')' ';'
			 {
				 string blend_name=$3.strs[0];
				 string vec4text=$5.strs[0];
				 buildPassState.blendState=blend_name;
				 unsigned mask=$7.unum;
			 };

shader_def : shader_lvalue '=' shader_rvalue ';'	// Something like vs(430) = vs_main;
			{
				$$.strs[0] = "";
				$$.strs[1] = "";
				$$.strs[2] = "";
				errSem("Pass definitions like vs(430)=vs_main are no longer supported. Please use SetVertexShader() etc.");
			}
			// For example: SetVertexShader(vs_main);
			| SHADER_COMMAND '(' shader_compile ')' ';'
			{
				$$.strs[0]	="";
				$$.strs[1]	="";
				$$.strs[2]	="";
				$$.sType	=$1.sType;//(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
				// the shader_variable is something like vs_main, for which we have a compile command like:
				//												VertexShader vs_layers=CompileShader(430,VS_Layers());
				// i.e. it's a combination of shadertype, profile, and function name.
				// so these are stored in gEffect->GetCompiledShaders().
				string compiledShaderName=$3.strs[0];
				CompiledShaderMap::const_iterator i=gEffect->GetCompiledShaders().find(compiledShaderName);
				if(i==gEffect->GetCompiledShaders().end())
				{
					if(_stricmp(compiledShaderName.c_str(),"NULL")==0)
					{
					}
					else
					{
						ostringstream errMsg;
						errMsg<<"Unable to find compiled shader \""<<compiledShaderName<<'\"';
						errSem(errMsg.str(), $3.lineno);
					}
				}
				else
				{
					CompiledShader *compiledShader	=i->second;
					$$.num							=compiledShader->version;
					$$.sCommand						=$1.sCommand;
					$$.sType						=$1.sType;
					if($$.sType!=$3.sType)
					{
						if($$.sType==GEOMETRY_SHADER&&$3.sType==VERTEX_SHADER)
						{
							$$.strs[0]	="";
							$$.strs[1]	="";
							$$.strs[3]	="NULL";
						}
						else
						{
							errSem((((string("Shader type mismatch for ")+compiledShaderName+" - can't call ")+$1.strs[0]+" with ")+ShaderTypeToString($3.sType)+" shader as input.").c_str());
						}
					}
					else
					{
						ostringstream preamble;
						preamble << "#version " << compiledShader->version << endl;
						glfxParser::ShaderCommand shaderCommand=$1.sCommand;
						if(shaderCommand<NumShaderCommands)
						{
							string shaderName=compiledShader->m_functionName;
							if(_stricmp(shaderName.c_str(),"NULL")!=0)
							{
								if (shaderCommand == COMPUTE_SHADER)
								{
									preamble << gEffect->GetComputeLayouts().find(shaderName)->second.text() << "\n";
									preamble << "#define IN_COMPUTE_SHADER 1" << endl;
								//	preamble << computeLayout << "\n"; 
								}
								if (shaderCommand ==FRAGMENT_SHADER)
								{
									preamble << "#define GLFX_FRAGMENT_SHADER 1" << endl;
								}
							}
							$$.strs[0]	=preamble.str();
							$$.strs[1]	=shaderName;
							$$.strs[3]	=compiledShaderName;
							//if (shaderCommand == COMPUTE_SHADER)
							//	$$.strs[2] = gEffect->m_shaderLayouts[shaderName].text();
						}
					}
				}
			};
shader_compile: IDENTIFIER
		{
			string compiledShaderName	=$1.strs[0];
			CompiledShaderMap::const_iterator i=gEffect->GetCompiledShaders().find(compiledShaderName);
			if(i!=gEffect->GetCompiledShaders().end())
				$$.sType				=i->second->shaderType;
			else
				$$.sType				=NUM_OF_SHADER_TYPES;
			$$.strs[0]					=compiledShaderName;
			$$.num						=0;
			$$.lineno					=$1.lineno;
		}
		| CONSTRUCT_GS_WITH_SO '(' IDENTIFIER ',' QUOTED_STRING ')' 
		{
			$$.lineno								=$5.lineno;
			$$.sType								=GEOMETRY_SHADER;
			string gsName							=$3.strs[0];
			string definition						=$5.strs[0];
			CompiledShaderMap::const_iterator i		=gEffect->GetCompiledShaders().find(gsName);
			string tempName							=gsName+"_GS_with_SO";
			$$.strs[0]								=tempName;
		
			if(i==gEffect->GetCompiledShaders().end())
			{
				ostringstream msg;
				msg<<"Compiled shader "<<gsName<<" not found for streamout"<<endl;
				errSem(msg.str().c_str());
			}
			else
			{
				CompiledShader *compiledShader	=i->second;
				const CompiledShader *new_cs	=gEffect->AddCompiledShader(tempName,gsName,GEOMETRY_SHADER,0,compiledShader->outputStruct
																			,compiledShader->outputStructName
																			,compiledShader->source);
				std::vector<std::string> feedbackOutput;
				if(definition.size())
				{
					find_and_replace(definition,"\"","");
					std::vector<std::string> elements=split(definition,';');
					feedbackOutput.clear();
					auto u=gEffect->GetStructs().find(new_cs->outputStruct);
					if(u==gEffect->GetStructs().end())
					{
						errSem(string("can't find output struct ")+new_cs->outputStruct);
					}
					else
					for(int i=0;i<elements.size();i++)
					{
						const Struct *struc=(u->second);
						string decl=elements[i];
						vector<string> parts=split(decl,'.');
						if(parts.size()!=1&&parts.size()!=2)
						{
							errSem("Invalid Streamout definition");
							continue;
						}
						string semantic=parts[0];
						string swizzle;
						if(parts.size()==2)
							swizzle=parts[1];
						for(int i=0;i<(int)struc->m_structMembers.size();i++)
						{
							const StructMember &m=struc->m_structMembers[i];
							if(m.semantic==semantic)
							{
								string modified=(new_cs->outputStructName+".")+m.name;
								if(swizzle.size())
								{
								//	modified+=".";
								//	modified+=swizzle;
								}
								feedbackOutput.push_back(modified);
								break;
							}
						}
					}
				}
			}
		}
		| COMPILE_SHADER '(' SHADER_PROFILE ',' IDENTIFIER '(' ')' ')' 
		{
			$$.lineno								=$5.lineno;
			$$.sType								=$3.sType;
			string profileName						=$3.strs[0];
			$$.token								=$3.token;
			ProfileMap::const_iterator i			=gEffect->GetProfileToVersion().find(profileName);
			int version_num							=0;
			if(i==gEffect->GetProfileToVersion().end())
			{
				ostringstream msg;
				msg<<"Profile "<<profileName<<" not found."<<endl;
				errSem(msg.str().c_str());
			}
			else
				version_num=i->second;
			string shaderName=$5.strs[0];
			stringstream ss;
			ss << $5.strs[0]<<"Compiled"<<version_num;
			string compiledShaderName						=ss.str();
			$$.strs[0]										=compiledShaderName;
			auto u=compilableShaders.find(shaderName);
			if(u==compilableShaders.end())
			{
				errSem(string("Can't find shader ")+shaderName);
			}
			else
			{
				CompilableShader &sh=*(u->second);
				gEffect->AddComputeLayout(shaderName,sh.csLayout);

				gEffect->MergeTextureSamplers(sh.function->textureSamplers,shaderName);

				const CompiledShader *cs=gEffect->AddCompiledShader(compiledShaderName,$5.strs[0],$1.sType,version_num);
				$$.num=version_num;
				// "Compile" the shader - in the sense of "concatenate the strings and prepare it as GLSL source":
				gEffect->Compile($1.sType, sh, compiledShaderName);
			}
		};
shader_lvalue : SHADER_TYPE '(' NUM ')'
				{
					$$.num	=$3.num;
					$$.sType=$1.sType;
				};
/*shader_variable:NUM ',' IDENTIFIER
				{
					$$.strs[0]=$3.strs[0];
					$$.num=$1.num;
					$$.lineno=$3.lineno;
				};*/
shader_rvalue : IDENTIFIER '(' ')' shader_layout
				{
					$$.lineno=$1.lineno;
					$$.strs[0]=$1.strs[0];
					$$.strs[1]=$4.strs[0];
				}
				|
				{
					$$.num=0;
				};
shader_layout : ':' shader_layout_list
				{
					$$.strs[0]=$2.strs[0];
				}
				|
				{
					$$.strs[0]="";
				};

shader_layout_list : shader_layout_list ',' layout
				{
					$$.strs[0]=$1.strs[0];
					$$.strs[0]+=$3.strs[0];
				}
				| layout
				{
					$$.strs[0]=$1.strs[0];
				};
statement_list: statement_list statement
				{
					string statement_list=$1.strs[0];
					string statement=$2.strs[0];
					$$.strs[0]	=statement_list;
					$$.strs[0]	+=statement;
					$$.strs[1]	=$1.strs[1]+$2.strs[1];
				}
				|
				statement
				{
					string statement=$1.strs[0];
					$$.strs[0]	=statement;
					$$.strs[1]	=$1.strs[1];
				}
				|
				{
					$$.strs[0]	="";
					$$.strs[1]	="";
				}
line_statement_in_shader: LINE NUM NUM EOL
	{
		last_linenumber		=$2.num;
		current_filenumber	=$3.num;
		global_linenumber	=$1.lineno+1;
		$$.strs[0]			=$1.strs[0]+" ";
		$$.strs[0]			+=$2.strs[0]+" ";
		$$.strs[0]			+=$3.strs[0];
		$$.strs[0]			+='\n';
	}
		/*
		THE FOLLOWING IS BASED ON THE K&R BNF for C:
		*/
declaration	: type_spec init_declarator_list
		{
			string type_spec=$1.strs[0];
			$$.strs[0]=type_spec+" ";
			string init_declarator_list=$2.strs[0];
			if(type_spec=="float")
				type_spec="";
			stringReplaceAll(init_declarator_list,"%type%",type_spec);
			stringReplaceAll(init_declarator_list,type_spec+type_spec,type_spec);
			$$.strs[0]+=init_declarator_list;
		}
init_declarator_list	: init_declarator
		{
			$$.strs[0]=$1.strs[0];
		}
			| init_declarator_list ',' init_declarator
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
init_declarator		: declarator
		{
			$$.strs[0]=$1.strs[0];
		}
		| declarator '=' initializer
		{
			// An expression of the form vec2 c=....;
			// Pass-through normally, but most GLSL compilers cannot handle array initializers.
			string declarator	=$1.strs[0];
			string initializer	=$3.strs[0];
			if($3.children.size()<=1)
			{
				$$.strs[0]=$1.strs[0]+$2.strs[0]+initializer;
			}
			else
			{
				ostringstream declare_lines;
				/* Here we convert an expression of the form 
										vec2 poss[2]=
										{
											{ 1.0,-1.0},
											{ 1.0, 1.0},
										};
				to the form:
										vec2 poss[2];
										poss[0]=vec2(1.0,-1.0);
										poss[1]=vec2(1.0, 1.0);
				Only trouble is, we don't yet have the "vec2" or whatever the type is. So we will insert a special %type% wildcard for now.
										*/
				
				string name=$1.strs[0];
				size_t sq_pos=(int)name.find("[");
				// Ugly test to see if we're initializing a list here:
				if(sq_pos<name.length())
				{
					name=name.substr(0,sq_pos);
					declare_lines<<$1.strs[1]<<"["<<$3.children.size()<<"];\n";
					for(int i=0;i<$3.children.size();i++)
					{
						string c=$3.children[i].strs[0];
						std::replace( c.begin(), c.end(), '{', '('); 
						std::replace( c.begin(), c.end(), '}', ')'); 
						declare_lines<<"\t"<<name<<"["<<i<<"]=%type%"<<c<<";\n";
					}
				}
				else
				{
					declare_lines<<$1.strs[0]<<";\n";
					// So we're probably initializing a struct instead.
					errSem("Don't yet know how to handle initialization lists for non-arrays!");
				}
				$$.strs[0]=declare_lines.str();
			}
		}
declarator: IDENTIFIER
		{
			$$.strs[0]=$1.strs[0];
		}
		| '(' declarator ')'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
		| declarator '[' NUM ']'
		{
			$$.num=$3.num;
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0];
			$$.strs[1]=$1.strs[0];
			$$.strs[2]=$3.strs[0];
		}
		| declarator '['		']'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
			$$.strs[1]=$1.strs[0];
		}
		| declarator '('		')'
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
statement:	COMMENT
			{
				$$.strs[0]=$1.strs[0];
				$$.strs[1]="";
			}
			| WHITESPACE
			{
				$$.strs[0]=$1.strs[0];
			}
			| expression ';'
			{
				$$.strs[0]=$1.strs[0]+$2.strs[0];
				$$.lineno=$1.lineno;
				$$.strs[1]="";
			}
			|  ';'
			{
				$$.strs[0]=$1.strs[0];
				$$.strs[1]="";
			}
			| declaration ';'
			{
				$$.strs[0]=$1.strs[0]+$2.strs[0];
				$$.strs[1]="";
			}
			| compound_statement
			{
				string compound_statement=$1.strs[0];
				$$.strs[0]=compound_statement;
				$$.strs[1]="";
			}
			| IF '(' expression ')' statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
					$$.strs[1]="";
				}
			| IF '(' expression ')' statement ELSE statement
				{
					string s1=$1.strs[0];
					string s2=$2.strs[0];
					string s3=$3.strs[0];
					string s4=$4.strs[0];
					string s5=$5.strs[0];
					string s6=$6.strs[0];
					string s7=$7.strs[0];
					$$.strs[0]=(s1+s2+s3+s4+s5+s6+"\n")+s7;
					$$.strs[1]="";
				}
			| WHILE '(' expression ')' statement
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
					$$.strs[1]="";
				}
			| DO statement WHILE '(' expression ')' ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0];
					$$.strs[1]="";
				}
			| FOR '(' for_init_statement ';' optional_expression ';' optional_expression ')' statement
				{
					string statement=$9.strs[0];
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0]+$8.strs[0]+statement;
					$$.strs[1]="";
				}
			| GOTO IDENTIFIER ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
					$$.strs[1]="";
				}
			| CONTINUE ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
					$$.strs[1]="";
				}
			| BREAK ';'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0];
					$$.strs[1]="";
				}
			| RETURN optional_expression ';'
			{
				string optional_expression=$2.strs[0];
				if(read_shader&&optional_expression.length()>0)
				{
					$$.strs[0]="";
					$$.strs[1]=optional_expression;
				}
				else
				{
					$$.strs[0]=($1.strs[0]+" ")+optional_expression+$3.strs[0];
					$$.strs[1]=optional_expression;
				}
				$$.lineno=$1.lineno;
			}
			| line_statement_in_shader
			{
				$$.strs[0]=$1.strs[0];
				$$.strs[1]="";
				$$.lineno=$1.lineno;
			}
for_init_statement: expression
			{
				$$.strs[0]=$1.strs[0];
			}
			| declaration
			{
				$$.strs[0]=$1.strs[0];
			}
			|
			{}

optional_expression: expression
			{
				$$.strs[0]=$1.strs[0];
			}
			|
			{
				$$.strs[0]="";
			}
/* multiple statements in braces*/
compound_statement	: '{' statement_list '}'
				{
					string statement_list=$2.strs[0];
					$$.strs[0]=$1.strs[0]+statement_list+$3.strs[0];
				}

expression: assignment_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| expression ',' assignment_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
assignment_exp: conditional_exp
		{
			$$.strs[0]=$1.strs[0];
		}
		| unary_exp assignment_operator assignment_exp
		{
			string unary_exp			=$1.strs[0];
			string assignment_operator	=$2.strs[0];
			string assignment_exp		=$3.strs[0];
			string varName				=$1.strs[1];
			string index				=$1.strs[3];
			// Is it actually a texture we're indexing?
			GLTextureType glTextureType			=GetTextureType(buildFunction,varName);
			if(glTextureType==0||!IsRWTexture(glTextureType))
			{
				$$.strs[0]=unary_exp+assignment_operator+assignment_exp;
			}
			else
			{
				ostringstream str;
				if($2.token=='=')
					str<<"imageStore("<<varName<<",ivec"<<GetTextureDimension(glTextureType)<<"("<<index<<"),convertToImageFormatof_"<<varName<<"("<<assignment_exp<<"))";
				else
					errSem(string("Unsupported operator for image store: ")+assignment_operator);
				$$.strs[0]=str.str();
			}
		}
assignment_operator: '='	
				{
					$$.strs[0]=$1.strs[0];
					$$.token=$1.token;
				}
				| TIMES_EQUALS
							| OVER_EQUALS
							| PERCENT_EQUALS
							| PLUS_EQUALS
							| MINUS_EQUALS
							| LEFT_SHIFT_EQUALS
							| RIGHT_SHIFT_EQUALS
							| AND_EQUALS
							| XOR_EQUALS
							| OR_EQUALS
	{
		$$.strs[0]=$1.strs[0];
		$$.token=$1.token;
	}
	conditional_exp		: logical_or_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| logical_or_exp '?' expression ':' conditional_exp
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
		}
	;
logical_or_exp: logical_and_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| logical_or_exp OR logical_and_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
logical_and_exp: inclusive_or_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| logical_and_exp AND inclusive_or_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
inclusive_or_exp	: exclusive_or_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| inclusive_or_exp '|' exclusive_or_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
exclusive_or_exp	: and_exp
				{
					$$.strs[0]=$1.strs[0];
				}
			| exclusive_or_exp '^' and_exp
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
and_exp			: equality_exp
{
	$$.strs[0]=$1.strs[0];
}
			| and_exp '&' equality_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			;
equality_exp		: relational_exp
{
	$$.strs[0]=$1.strs[0];
}
			| equality_exp EQ_EQ relational_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| equality_exp NOT_EQ relational_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
relational_exp		: shift_expression
{
	$$.strs[0]=$1.strs[0];
}
			| relational_exp '<' shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp '>' shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp LESS_EQ shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| relational_exp GRTR_EQ shift_expression
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
shift_expression	: additive_exp
{
	$$.strs[0]=$1.strs[0];
}
			| shift_expression LEFT_SHIFT additive_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| shift_expression RIGHT_SHIFT additive_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
additive_exp		: mult_exp
{
	$$.strs[0]=$1.strs[0];
}
			| additive_exp '+' mult_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| additive_exp '-' mult_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
mult_exp		: cast_exp
{
	$$.strs[0]=$1.strs[0];
}
			| mult_exp '*' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
			| mult_exp '/' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
| mult_exp '%' cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
}
cast_exp		: unary_exp
{
	$$.strs[0]=$1.strs[0];
}
unary_exp		: postfix_exp
{
	$$.strs[0]=$1.strs[0];
	$$.strs[1]=$1.strs[1];
	$$.strs[2]=$1.strs[2];
	$$.strs[3]=$1.strs[3];
}
			| PLUS_PLUS unary_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
			| MINUS_MINUS unary_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
			| unary_operator cast_exp
{
	$$.strs[0]=$1.strs[0]+$2.strs[0];
}
unary_operator		: '&' | '*' | '+' | '-' | '~' | '!'
{
	$$.strs[0]=$1.strs[0];
}
sampling_command: SAMPLE
{
	$$.strs[0]="texture";
}
| SAMPLE_LOD
{
	$$.strs[0]="textureLod";
}
tex_load_command: LOAD
{
	$$.strs[0]="texelFetch";
}
tex_load_exp:	postfix_exp '.' tex_load_command
					{
						string texture=$1.strs[0];
						string command=$3.strs[0];
						$$.strs[0]=texture+$2.strs[0]+command;
						// Put the thing we're sampling into strs[1]
						$$.strs[1]=texture;
						// We put the command into strs[2]
						$$.strs[2]=command;
					}
sampling_exp:	postfix_exp '.' sampling_command
					{
						string texture=$1.strs[0];
						string command=$3.strs[0];
						$$.strs[0]=texture+$2.strs[0]+command;
						// Put the thing we're sampling into strs[1]
						$$.strs[1]=texture;
						// We put the command into strs[2]
						$$.strs[2]=command;
					}
get_dims_exp:	postfix_exp '.' GET_DIMS
					{
						string texture=$1.strs[0];
						string command=$3.strs[0];
						$$.strs[0]=texture+$2.strs[0]+command;
						// Put the thing we're sampling into strs[1]
						$$.strs[1]=texture;
						// We put the command into strs[2]
						$$.strs[2]=command;
					}
postfix_exp		: primary_exp
					{
						$$.token=$1.token;
						string varName = $1.strs[0];
						$$.strs[0]= varName;
						$$.strs[2]= varName;			//Command
					}
					| postfix_exp '[' expression ']'
					{
						string varName=$1.strs[0];
						string index=$3.strs[0];
						$$.strs[1]=varName;
						$$.strs[3]=index;
						$$.strs[2]=$1.strs[2];			//Command

						// Is it actually a texture we're indexing?
						GLTextureType glTextureType			=GetTextureType(buildFunction,varName);
						if(glTextureType==0)
						{
							$$.strs[0]=varName+$2.strs[0]+index+$4.strs[0];
						}
						else
						{
							buildFunction.declarations.insert(varName);
							ostringstream str;
							if(IsRWTexture(glTextureType))
							{
								str<<"imageLoad("<<varName<<",ivec"<<GetTextureDimension(glTextureType)<<"("<<index<<"))";
							}
							else
							{
								str<<"texelFetch("<<varName<<",ivec"<<GetTextureDimension(glTextureType)<<"("<<index<<"),0)";
							}
							$$.strs[0]=str.str();
						}
					}
					| get_dims_exp '(' assignment_exp ',' assignment_exp ')'
					{
						string textureName	=$1.strs[1];
						string x			=$3.strs[0];
						string y			=$5.strs[0];
						
						$$.strs[0]=GetSizeFunction( textureName, x, y,"");
						buildFunction.declarations.insert(textureName);
					}
					| get_dims_exp '(' assignment_exp ',' assignment_exp ',' assignment_exp ')'
					{
						string textureName	=$1.strs[1];
						string x			=$3.strs[0];
						string y			=$5.strs[0];
						string z			=$7.strs[0];
						$$.strs[0]=GetSizeFunction( textureName, x, y,z);
						buildFunction.declarations.insert(textureName);
					}
					| tex_load_exp '(' argument_exp_list ')'
					{
						string textureName		=$1.strs[1];
						string command			=$1.strs[2];
						string pos,msaa_index;
						if($3.vars)
						{
							auto vars=*($3.vars);
							delete $3.vars;
							pos				=vars[0].identifier;
							
							if(vars.size()>1)
								msaa_index=vars[1].identifier;
						}
						int glTextureType	=(GetTextureType(buildFunction,textureName));
						int return_size=2;
						switch(glTextureType)
						{
						case gsampler1D:
						case sampler1DShadow:
						case gsamplerBuffer:
							return_size=1;
							break;
						case gsampler3D:
						case gsamplerCubeArray:
						case samplerCubeArrayShadow:
						case gsampler2DArray:
						case gsampler2DMSArray:
						case sampler2DArrayShadow:
						case gimage3D:
						case gimage2DArray:
						case gimage2DMSArray:
							return_size=3;
							break;
						default:
							break;
						}
						ostringstream full_expr;
						full_expr<<command<<"("<<textureName<<","<<pos<<".xy";
						if(return_size==3)
							full_expr<<"z,"<<pos<<".w";
						else if(!msaa_index.length())
							full_expr<<","<<pos<<".z";
						else
							full_expr<<",int("<<msaa_index<<")";
						full_expr<<")";
						$$.strs[0]				=full_expr.str();
						buildFunction.declarations.insert(textureName);
					}
					| sampling_exp '(' assignment_exp ',' argument_exp_list ')'
					{
						string textureName		=$1.strs[1];
						string command			=$1.strs[2];
						string samplerStateName	=$3.strs[0];
						string otherParams		=$5.strs[0];
						
						buildFunction.declarations.insert(textureName);
						// The actual texturing command depends on the type of the texture.
						if(IsDeclared(textureName))
						{
							string type=GetDeclaredType(textureName);
							if(type==string("samplerCube"))
							{
							//.	command="texture";
							}
						}
						if(!IsDeclared(samplerStateName))
						{
							errSem(string("Undeclared sampler state ")+samplerStateName);
						}
						// The first argument is the sampler state, the second is the texcoords, the third if present is the lod.
						// So: to translate this to GLSL, an expression like
						//			mainTexture.Sample(samplerState1,texcoords)
						// becomes:
						//			texture(mainTexture&samplerState1,texcoords)
						// and we will map the string "mainTexture&samplerState1" to mainTexture and samplerState1.

						// Later, if we call the function, we will insert it into the shader code.
						// each Texture parameter must be replaced by a list of all the texture-sampler combinations that use it.
						// each SamplerState parameter must be replaced by a list of the texture-sampler combinations that use it.
						// This might lead to some doubling-up.
						TextureSampler *ts=AddTextureSampler(textureName,samplerStateName);
						string full_expr=(command+"(")+(ts->textureSamplerName()+",")+otherParams+")";
						$$.strs[0]=full_expr;

						// There are four possibilities for each sampling command:
						// 1. both the texture and the sampler are declared globally.
						// 2. The texture is a function parameter and the sampler is declared globally.
						// 3. The texture is declared globally and the sampler is a function parameter.
						// 4. The texture and the sampler are function parameters.

						// In case 1., we insert the textureSampler declaration at the top, and in C++ apply that sampler to the texture.

						// In case 2., we replace the texture parameter with as many textureSampler parameters as needed.
						//				In the calls to this function we replace the texture parameter with the textureSamplers.
						// In case 3., we replace the sampler parameter with as many textureSampler parameters as needed.
						//				In the calls to this function we replace the sampler parameter with the textureSamplers.
						// In case 4., we replace the texture with as many textureSampler parameters as needed, and remove the sampler parameters.

						// Initially we will only implement cases 1 and 2.
					}
					| postfix_exp '(' argument_exp_list ')'
					{
						string expr1=$1.strs[0];
						string expr2=$2.strs[0];
						string params;
						auto vars			=*($3.vars);
						delete $3.vars;
						string expr4		=$4.strs[0];
						// ok this could be a function call.(((std::basic_string<char,std::char_traits<char>,std::allocator<char> >*)(&(command)))->_Bx._Buf)[0]=='d'
						string command		=$1.strs[2];
						const std::map<std::string,std::vector<Function*> > &functions=gEffect->GetFunctions();
						auto j=functions.find(command);
						if(j==functions.end())
						{
							params=$3.strs[0];
						}
						else
						{
							int num=0;
							for(auto u=j->second.begin();u!=j->second.end();u++)
							{
								if((*u)->parameters.size()!=vars.size())
									continue;
								buildFunction.functionsCalled.insert(*u);
								num++;
							}
							for(auto u=j->second.begin();u!=j->second.end();u++)
							{
								if((*u)->parameters.size()!=vars.size())
									continue;
								const Function &f=**u;
								// If it's a known function, there may need to be a mapping from the texture and sampler parameters.
								// We figure out this mapping by looking at the vars list of the function we're calling.
								//	this is the unmodified list, so it corresponds to the call we're making.
								for(vector<glfxstype::variable>::const_iterator i=f.expanded_parameters.begin();i!=f.expanded_parameters.end();i++)
								{
									string declared_name=i->identifier;
									// That's how the parameter was declared. Is it in the original list?
									int index=GetIndexOfParameter(f.parameters,declared_name);
									auto u=f.textureSamplers.find(declared_name);
									if(u!=f.textureSamplers.end())
									{
										TextureSampler *ts		=u->second;
										int t					=GetIndexOfParameter(f.parameters,ts->textureName);
										int s					=GetIndexOfParameter(f.parameters,ts->samplerStateName);
										string textureName		=ts->textureName;
										string samplerStateName	=ts->samplerStateName;
										if(t>=0)
											textureName			=(vars[t]).identifier;
										if(s>=0)
											samplerStateName	=(vars[s]).identifier;
										TextureSampler *ts_new=AddTextureSampler(textureName,samplerStateName);
										if(params.size())
											params+=",";
										params+=ts_new->textureSamplerName();
									
									}
									// If so we pass the corresponding parameter from the call.
									else if(index>=0)
									{
										const glfxstype::variable &p=vars[index];
										if(params.size())
											params+=",";
										params+=p.identifier;
									}
									else // could be a textureSampler...
									{
										if(params.size())
											params+=",";
										params+=declared_name;
									}
								}
								for(auto j=f.textureSamplers.begin();j!=f.textureSamplers.end();j++)
								{
									TextureSampler *ts		=j->second;
									if(ts->global)
										AddTextureSampler(ts->textureName,ts->samplerStateName)->global=true;
								}
								break;
							}
							if(num==0)
							{
								errSem(string("No matching function definition found for ")+command);
								break;
							}
						}
						$$.strs[0]=expr1+expr2+params+expr4;
					}
					| postfix_exp '(' ')'
					{
						// ok this could be a function call.
						string command=$1.strs[2];
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
					}
					| postfix_exp '.' IDENTIFIER
					{
						string expr1=$1.strs[0];
						string expr3=$3.strs[0];
						$$.strs[2]=expr3;			//Command
						$$.strs[0]=expr1+$2.strs[0]+expr3;
					}
					| postfix_exp PLUS_PLUS
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0];
					}
					| postfix_exp MINUS_MINUS
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0];
					}
argument_exp_list	: argument_exp_list ',' assignment_exp
					{
						$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
						$$.vars=$1.vars;
						YYSTYPE::variable var;
						var.identifier	=$3.strs[0];
						$$.vars->push_back(var);
					}
					| assignment_exp
					{
						$$.strs[0]=$1.strs[0];
						$$.vars = new vector<YYSTYPE::variable>;
						YYSTYPE::variable var;
						var.identifier	=$1.strs[0];
						$$.vars->push_back(var);
					}
initializer		: assignment_exp
				{
					string assignment_exp = $1.strs[0];
					$$.strs[0]=assignment_exp;
				}
			| '{' initializer_list '}'
				{
					vector<glfxstype> &children = $$.children;
					children = $2.children;
					string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0];
					$$.strs[0] = initlist;
				}
			| '{' initializer_list ',' '}'
			{
					vector<glfxstype> &children = $$.children;
					children = $2.children;
					string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0] + $4.strs[0];
					$$.strs[0] = initlist;
				}
initializer_list: initializer
				{
					vector<glfxstype> &children = $$.children;
					children.clear();
					children.push_back($1);
					$$.strs[0]=$1.strs[0];
				}
			| initializer_list ',' initializer
				{
					vector<glfxstype> &children = $$.children;
					children = $1.children;
					children.push_back($3);
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
primary_exp	: IDENTIFIER
				{
					string varName=$1.strs[0];
					$$.strs[0]=varName;
					if(gEffect->IsTextureDeclared(varName))
						buildFunction.declarations.insert(varName);
				}
			| SATURATE
				{
					$$.token=$1.token;
					$$.strs[0]=$1.strs[0];
				}
			| const
				{
					$$.strs[0]=$1.strs[0];
				}
			| '(' expression ')'
				{
					$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
				}
const		: NUM
				{
					$$.strs[0]=$1.strs[0];
				}
			| P_FLOAT
				{
					$$.strs[0]=$1.strs[0];
				}
layout : STORAGEQ read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	};

layout : GL_FRAGDEPTH read_parenthesis
	{
		ostringstream layoutDef;
		//layoutDef<<"#line "<<$1.lineno<<endl;
		layoutDef<<"layout"<<$2.strs[0]<<' '<<"out float "<<$1.strs[0]<<';'<<endl;
		$$.strs[0]=layoutDef.str();
	};

read_parenthesis :
	{ /* read parenthesis */
		$$.strs[0]=glfxreadblock('(', ')');
	};
optional_register_semantic: ':' REGISTER '(' IDENTIFIER ')'
					{
						string id	=$4.strs[0];
						$$.strs[0]	=id;
						$$.num		=-1;
						if(id.length()>1)
						{
							string nstr	=id.substr(1,id.length()-1);
							int num		=atoi(nstr.c_str());
							$$.num		=num;
						}
					}
					|
					{
						$$.strs[0]	="";
						$$.num		=-1;
					}
optional_semantic: ':' IDENTIFIER
					{
						$$.strs[0]		=$2.strs[0];
					}
					| ':' input_semantic
					{
						$$.strs[0]		=$2.strs[0];
					}
					|
					{
						$$.strs[0]="";
					}
optional_render_state_list:	'{' render_state_list '}'
					{
						$$.lineno		=$2.lineno;
					}|
					{
					}
// render_state_list must pass up an array of commands. Each command has a name, a number, and a value.
render_state_list : render_state_list render_state_command
					{
						$$.lineno		=$2.lineno;
					}
					|
					render_state_command
					{
						$$.lineno		=$1.lineno;
					};
render_state_command : render_state_identifier '=' render_state_rvalue ';'
					   {
							$$.lineno		=$3.lineno;
							string name		=$1.strs[0];
							string value	=$3.strs[0];
							int token		= $3.token;
							int index		=$1.num;
							int ival		=$3.num;
							float fval		=$3.fnum;
							bool bval		=(ival!=0);
							if(renderState==RASTERIZER_STATE)
							{
								if(is_equal(name,"FillMode"))
									buildRasterizerState.FillMode=(GLenum)toFillModeGLenum(token);
								else if(is_equal(name,"CullMode"))
									buildRasterizerState.CullMode=(GLenum)toCullModeGLenum(token);
								else if(is_equal(name,"FrontCounterClockwise"))
									buildRasterizerState.FrontCounterClockwise=toBool(value);
								else if(is_equal(name,"DepthBias"))
									buildRasterizerState.DepthBias=ival;
								else if(is_equal(name,"DepthBiasClamp"))
									buildRasterizerState.DepthBiasClamp=fval;
								else if(is_equal(name,"SlopeScaledDepthBias"))
									buildRasterizerState.SlopeScaledDepthBias=fval;
								else if(is_equal(name,"DepthClipEnable"))
									buildRasterizerState.DepthClipEnable=toBool(value);
								else if(is_equal(name,"ScissorEnable"))
									buildRasterizerState.ScissorEnable=toBool(value);
								else if(is_equal(name,"MultisampleEnable"))
									buildRasterizerState.MultisampleEnable=toBool(value);
								else if(is_equal(name,"AntialiasedLineEnable"))
									buildRasterizerState.AntialiasedLineEnable=toBool(value);
								else
								{
									ostringstream str;
									str<<"Unknown rasterizer state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==DEPTHSTENCIL_STATE)
							{
								if(is_equal(name,"DepthEnable"))
									buildDepthStencilState.DepthEnable		=toBool(value);
								else if(is_equal(name,"DepthWriteMask"))
								{
									if(is_equal(value,"ALL"))
										buildDepthStencilState.DepthWriteMask	=1;
									else if(is_equal(value,"ZERO"))
										buildDepthStencilState.DepthWriteMask	=0;
									else 
										errSem("Unknown depth write mask");
								}
								else if(is_equal(name,"DepthFunc"))
									buildDepthStencilState.DepthFunc=(GLenum)toDepthFuncGLEnum(token);
								else
								{
									ostringstream str;
									str<<"Unknown DepthStencil state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==BLEND_STATE)
							{
								if(is_equal(name,"SrcBlend"))
									buildBlendState.SrcBlend=(GLenum)toBlendGLEnum(token);
								else if(is_equal(name,"DestBlend"))
									buildBlendState.DestBlend=(GLenum)toBlendGLEnum(token);
								else if(is_equal(name,"BlendOp"))
									buildBlendState.BlendOp=(GLenum)toBlendOpGLEnum(token);
								else if(is_equal(name,"SrcBlendAlpha"))
									buildBlendState.SrcBlendAlpha=(GLenum)toBlendGLEnum(token);
								else if(is_equal(name,"DestBlendAlpha"))
									buildBlendState.DestBlendAlpha=(GLenum)toBlendGLEnum(token);
								else if(is_equal(name,"BlendOpAlpha"))
									buildBlendState.BlendOpAlpha=(GLenum)toBlendOpGLEnum(token);
								else if(is_equal(name,"AlphaToCoverageEnable"))
									buildBlendState.AlphaToCoverageEnable=toBool(value);
								else if(is_equal(name,"BlendEnable"))
									buildBlendState.BlendEnable[index]=toBool(value);
								else if(is_equal(name,"RenderTargetWriteMask"))
									buildBlendState.RenderTargetWriteMask[index]=ival;
								else
								{
									ostringstream str;
									str<<"Unknown blend state command: "<<name;
									errSem(str.str().c_str());
								}
							}
							if(renderState==SAMPLER_STATE)
							{
								if(is_equal(name,"Filter"))
								{
									buildSamplerState.MinFilter			=(GLenum)toMinFilterModeGLEnum(token);
									buildSamplerState.MagFilter			=(GLenum)toMagFilterModeGLEnum(token);
								}
								else if(is_equal(name,"AddressU"))
									buildSamplerState.AddressU			=(GLenum)toAddressModeGLEnum(token);
								else if(is_equal(name,"AddressV"))
									buildSamplerState.AddressV			=(GLenum)toAddressModeGLEnum(token);
								else if(is_equal(name,"AddressW"))
									buildSamplerState.AddressW			=(GLenum)toAddressModeGLEnum(token);
								else if(is_equal(name,"MipLODBias"))
									buildSamplerState.MipLODBias		=toFloat(value);
								else if(is_equal(name,"MaxLod"))
									buildSamplerState.MaxLod			=toFloat(value);
								else if(is_equal(name,"MinLod"))
									buildSamplerState.MinLod			=toFloat(value);
								else if(is_equal(name,"MaxAnisotropy"))
									buildSamplerState.MaxAnisotropy		=toFloat(value);
								else
								{
									ostringstream str;
									str<<"Unknown Sampler state command: "<<name;
									errSem(str.str().c_str());
								}
							}
						};
						|
						ignore_line_statement
						{
							$$.lineno	=$1.lineno;
							$$.num		=-1;
						  $$.strs[0]	="";
						};
render_state_identifier : IDENTIFIER optional_index
						{
							$$.lineno	=$1.lineno;
							$$.strs[0]	=$1.strs[0];
							$$.num		=$2.num;
						};
optional_index : '[' NUM ']'
						{
							 $$.num=$2.num;
							 $$.fnum=$2.fnum;
						}
						|
						{
							 $$.num=0;
						};
render_state_rvalue: IDENTIFIER
					{
						$$.lineno = $1.lineno;
						$$.strs[0] = $1.strs[0];
					}
					| NUM
					{
						$$.lineno = $1.lineno;
						$$.num = $1.num;
						$$.token = $1.token;
					}
						| P_FLOAT
					{
						$$.lineno = $1.lineno;
						$$.fnum = $1.fnum;
						$$.token = $1.token;
					}
					| filter_mode
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| blend_mode
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| blend_op
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| cull_mode
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
						| fill_mode
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| RENDERSTATE_RVALUE_NONE
					{
						// THis could be different types depending on context: cull or fill.
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| depth_func
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| texture_addressing_mode
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
filter_mode: MIN_MAG_MIP_POINT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_MAG_POINT_MIP_LINEAR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_POINT_MAG_LINEAR_MIP_POINT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_POINT_MAG_MIP_LINEAR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_LINEAR_MAG_MIP_POINT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_LINEAR_MAG_POINT_MIP_LINEAR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_MAG_LINEAR_MIP_POINT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| MIN_MAG_MIP_LINEAR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
				| ANISOTROPIC
					{
						$$.lineno = $1.lineno;
						$$.token =$1.token;
					}
blend_mode: SRC_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_SRC_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| ZERO
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| ONE
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| SRC_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_SRC_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| DEST_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_DEST_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| DEST_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_DEST_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| SRC_ALPHA_SAT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| BLEND_FACTOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_BLEND_FACTOR
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| SRC1_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_SRC1_COLOR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| SRC1_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| INV_SRC1_ALPHA
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}

blend_op: BLEND_OP_ADD
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| BLEND_OP_SUBTRACT
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| BLEND_OP_MAX
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}

fill_mode: FILL_MODE_WIREFRAME
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| FILL_MODE_SOLID
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}

cull_mode:	CULL_FRONT_FACES
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
			| CULL_BACK_FACES
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
depth_func: DEPTH_PASS_ALWAYS
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| DEPTH_PASS_NEVER
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| DEPTH_PASS_LESS
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| DEPTH_PASS_GREATER
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| DEPTH_PASS_LESS_EQUAL
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}
			| DEPTH_PASS_GREATER_EQUAL
			{
				$$.lineno = $1.lineno;
				$$.token = $1.token;
			}

texture_addressing_mode: TEXTURE_WRAP
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| TEXTURE_MIRROR
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
					| TEXTURE_CLAMP
					{
						$$.lineno = $1.lineno;
						$$.token = $1.token;
					}
type_spec: IDENTIFIER
		{
			$$.strs[0]=$1.strs[0];
		}
%%

	GLTextureType ToGLTextureType(int t)
	{
		switch(t)
		{
		case TEXTURE2D:
			return gsampler2D;
		case TEXTURE2DMS:
			return gsampler2DMS;
		case TEXTURE3D:
			return gsampler3D;
		case TEXTURECUBE:
			return gsamplerCube;
		case TEXTURE2DARRAY:
			return gsampler2DArray;
		case RW_TEXTURE2D:
			return gimage2D;
		case IMAGE3D:
		case RW_TEXTURE3D:
		case RW_TEXTURE3D_FLOAT4:
			return gimage3D;
		case RW_TEXTURE2DARRAY:
			return gimage2DArray;
		default:
			return unknwownTextureType;
		};
	}
	string getGLInputSemantic(int s)
	{
		switch(s)
		{
		case SV_DISPATCHTHREADID:
			return "gl_GlobalInvocationID";
		case SV_GROUPTHREADID:
			return "gl_LocalInvocationID";
		case SV_GROUPID:
			return "gl_WorkGroupID";
		case SV_VERTEXID:
			return "gl_VertexID";
		default:
		break;
		};
		return "";
	}
	
	bool IsBufferType(int t)
	{
		switch(t)
		{
		case STRUCTUREDBUFFER:
		case RW_STRUCTUREDBUFFER:
			return true;
		default:
			return false;
		};
	}
void glfxWarning(const char* e)
{
    ostringstream errMsg;
	int lex_linenumber=glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
    errMsg<<current_filenumber<<"("<< true_linenumber<<") : glfx warning: \""<<glfxget_text()<<"\" "<<e<<std::endl;
	gEffect->Log()<<errMsg.str();
}

void glfxerror(const char* e)
{
    errSyn(e);
}

void errSyn(const char* e)
{
    ostringstream errMsg;
	int lex_linenumber=glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
	char txt[500];
	strcpy_s(txt,499,glfxget_text());
	txt[499]=0;
    errMsg<<current_filenumber<<"("<< true_linenumber<<") : glfx syntax error: \""<<txt<<"\" "<<e<<" in "<<glfxGetStateText();
    throw std::runtime_error(errMsg.str());
}

void errSem(const string& str, int lex_linenumber)
{
    ostringstream errMsg;
    
    if(lex_linenumber==-1)
        lex_linenumber= glfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
	char txt[500];
	strcpy_s(txt,499,glfxget_text());
	txt[499]=0;
    errMsg<<current_filenumber<<"("<<true_linenumber<<") : glfx error: "<<str<<" in "<<glfxGetStateText();
    throw std::runtime_error(errMsg.str());
}

void resetGlfxParse()
{
	buildFunction.clear();
	buildStruct		=Struct();
	gEffect->Clear();
	read_shader		=false;
	read_function	=false;
}
